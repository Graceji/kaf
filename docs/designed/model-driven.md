# 模型驱动

## 模型是什么？

这里的"**模型 Model**"是指对业务逻辑的抽象表达和数据建模。

模型与运行平台无关、与UI框架无关，它是一种逻辑、一种抽象、一种提炼。它是应用的骨骼，UI则是皮肉，所谓的模型驱动是一种设计理念：

> 用骨骼来驱动皮肉，而不是用皮肉来驱动骨骼。

## 模型就是状态吗？

模型是一个可以运转的有机体，而状态只是它的一个切片，模型包括状态、以及驱动状态变化的各种方法和事件。

## 模型驱动就是领域驱动吗？

模型驱动可以看作是DDD领域驱动在前端工程的白话版、简化版。

## 轻UI，重Model

你是否仍在纠结采用React还是Vue？是否仍被困于各种生命周期之中？是否迷惑于把获取数据写在onMounted还是onCreated中？那么你应当尝试着：

> 将更多逻辑从 UI 转移到 Model 中。

## 为什么需要模型驱动？

- 剥离了业务逻辑，UI层变得更纯粹，它只是负责展示、交互和传递用户事件。
- 剥离了UI逻辑，业务层不再受到各种生命周期和糖衣语法的干挠，更纯净透明。
- 分层而治，将稳定的`业务层`和灵活的`UI层`分离，增加了代码的可复用性和可移植性。

![elux模型驱动示意图](/images/model-reusable.svg)

## 借助于模型驱动实现跨端开发

用一套代码搞定不同的运行平台，`Write once run anywhere...`这曾经是我们美好的梦想，然而实践却告诉我们那样往往啥都干不好。因为不同平台的渲染原理、用户习惯、尺寸大小，表现方式本质上就不一样，非得强行将它们按平，那么只能是成就某些而放弃某些。

我们思考，运行在不同终端不同运行平台中唯一不变的是什么？是游戏规则，是**业务逻辑**，而`数据模型`就是业务逻辑的抽象载体。

所以，Elux追求的是**解题思路的复用**、**核心逻辑的复用**，并不追求`Write once run anywhere...`，它属于现实主义者，而非完美主义者！

## Elux中的模型驱动

Elux原意是 **Flux Enhancer**，是一种加强版的的Flux状态管理器(`Redux/Vuex都是Flux的变种`)，它主要加强了以下方面：

### 将Action作为Model中的事件

驱动应用运行需要事件，协同模块之间的工作也需要事件，事件是一种发布订阅的设计模式，在Model中我们称它为Action：

![elux模型驱动示意图1](/images/model1.svg)

当然它与UI中的Event机制完全不一样，比如UI中的Event有冒泡机制，而Model中的Action有线程机制（`在ActionHandler的执行过程中可以开启一条新的Action线程`）。

### 职能化和模块化

- 将 **ActionHandler** 分为`纯函数reducer`和`副作用effect`。其中 reducer 是唯一可以改变 State 的方法，其概念类似于`Redux 的 reducer`和`redux-saga 的 effect`，也类似于 Vuex 的`mutation`和`action`。
- 将 State 和 ActionHandler 都进行**模块化**，并添加约束：**本模块的State只能由本模块的reducer修改**

![elux模型驱动示意图2](/images/model2.svg)

### 将其它副作用挡在外围

Model 需保持足够抽象和纯粹，我们不希望在它里面引入更多副作用和不稳定因子，所以需要将这些噪音挡在外围，第一时间将它们转化为 Model 的内部语素。

我们知道MVVM理论有个深入人心的公式：

> UI = render(State)

然而在众多前端工程中，这个公式变得不那么纯粹。比如将路由直接与UI绑定起来，公式变成了：

> UI = route()+render(State)

要知道不同的UI框架、不同的运行平台，路由实现方案多种多样，这将让应用失去通用性。Elux打破了常规的做法，**将路由在外围与State绑定起来**，不直接参与UI的运算，让渲染公式回归纯粹。

![elux模型驱动示意图3](/images/model3.svg)

所以在Elux中不再需要任何路由框架(`如react-router、vue-router、taro-router等`)，也没有定死路由规则。路由只存在于 Model 外围，不参与核心逻辑，带来灵活性的同时也降低了心智负担。
