# 模型驱动

## 模型是什么？

这里的"**模型 Model**"是指对业务逻辑的抽象表达和数据建模。

模型与运行平台无关、与UI框架无关，它是一种逻辑、一种抽象、一种提炼。它是应用的骨骼，UI则是皮肉，所谓的模型驱动是一种设计理念：

> 用骨骼来驱动皮肉，而不是用皮肉来驱动骨骼。

## 模型就是状态吗？

模型是一个可以运转的有机体，而状态只是它的一个切片，模型包括状态、以及驱动状态变化的各种方法和事件。

## 模型驱动就是领域驱动吗？

模型驱动可以看作是DDD领域驱动在前端工程的白话版、简化版。

## 轻UI，重Model

你是否仍在纠结采用React还是Vue？是否仍被困于各种生命周期之中？是否迷惑于把获取数据写在onMounted还是onCreated中？那么你应当尝试着：

> 将更多逻辑从 UI 转移到 Model 中。

## 为什么需要模型驱动？

- 剥离了业务逻辑，UI层变得更纯粹，它只是负责展示、交互和传递用户事件。
- 剥离了UI逻辑，业务层不再受到各种生命周期和糖衣语法的干挠，更纯净透明。
- 分层而治，将稳定的`业务层`和灵活的`UI层`分离，增加了代码的可复用性和可移植性。

![elux模型驱动示意图](/images/model-reusable.svg)

## 借助于模型驱动实现跨端开发

跨端开发很难吗？一点都不难，你财大气粗可以每个端都招一组人马开发就得了，多少端都不是事儿。所以我们聊的跨端其实是如何节省人力成本、时间成本而进行“**跨端复用**”。

### 为什么不能跨端

我们回头想想应用为什么不能跨端呢？思维逻辑是无国界的，你可以借助任何一种语言来描述与表达，而Javascript运行时又被多种运行平台广泛支持，按理说跨端应当不难呀。

这个**魔障就是UI/UE**，这是一个感性的东西、它灵活多变、不但不存在标准反而还追求个性。各端都坚守自己用户习惯、设计风格、传统文化、个性表现、默认优化、方言约定等等，这已经不是技术范畴的事了，即便你强行抹平了，也只能顾此失彼...

为什么后端接口不需要跨端开发？(即便需要也仅仅是个BFF适配层)。因为后端是面向业务逻辑的开发，而前端是面向UI界面的开发。

所以最简单的跨端思路就是：

> 直面UI的个性化，把这层基于感性的、非标准的东西剥离出来，并尽可能削薄它。

### 从理想主义到现实主义

虽然`Write once run anywhere...`是很多人追求的梦想，但我不推崇它，因为即便是你做到了，也可能失去平台优化、失去个性色彩、在平台生态中沦为二等公民。

那么退而求其次`Learn Once, Write Anywhere...`，不追求那么完美，能复用`业务逻辑`、`解题思路`、`应用骨架`、`核心代码`，也是知足常乐的。

我们思考，运行在不同终端不同运行平台中唯一不变的是什么？是游戏规则，是**业务逻辑**，而`业务模型`就是业务逻辑的抽象载体。

### 从业务逻辑到业务模型

应用的核心是什么？是游戏规则，是**业务逻辑**，一个应用不管运行平台怎么变化，它的业务逻辑总是通行不变的。
如果我们再进一步对业务逻辑进行领域建模，去掉那些花里胡哨的修饰、让业务模型变得抽象、纯粹、精炼，那么我们将得到一个最有价值的、最稳定坚固的、放之四海而皆可行的核心逻辑。

至于UI表现要个性化？要平台化？那就重新作件漂亮的外衣呗...

## Elux中的模型驱动

Elux原意是 **Flux Enhancer**，是一种加强版的的Flux状态管理器(`Redux/Vuex都是Flux的变种`)，它主要加强了以下方面：

### 将Action作为Model中的事件

驱动应用运行需要事件，协同模块之间的工作也需要事件，事件是一种发布订阅的设计模式，在Model中我们称它为Action：

![elux模型驱动示意图1](/images/model1.svg)

当然它与UI中的Event机制完全不一样，比如UI中的Event有冒泡机制，而Model中的Action有线程机制（`在ActionHandler的执行过程中可以开启一条新的Action线程`）。

### 职能化和模块化

- 将 **ActionHandler** 分为`纯函数reducer`和`副作用effect`。其中 reducer 是唯一可以改变 State 的方法，其概念类似于`Redux 的 reducer`和`redux-saga 的 effect`，也类似于 Vuex 的`mutation`和`action`。
- 将 State 和 ActionHandler 都进行**模块化**，并添加约束：**本模块的State只能由本模块的reducer修改**

![elux模型驱动示意图2](/images/model2.svg)

### 将其它副作用挡在外围

Model 需保持足够抽象和纯粹，我们不希望在它里面引入更多副作用和不稳定因子，所以需要将这些噪音挡在外围，第一时间将它们转化为 Model 的内部语素。

我们知道MVVM理论有个深入人心的公式：

> UI = render(State)

然而在众多前端工程中，这个公式变得不那么纯粹。比如将路由直接与UI绑定起来，公式变成了：

> UI = route()+render(State)

要知道不同的UI框架、不同的运行平台，路由实现方案多种多样，这将让应用失去通用性。Elux打破了常规的做法，**将路由在外围与State绑定起来**，不直接参与UI的运算，让渲染公式回归纯粹。

![elux模型驱动示意图3](/images/model3.svg)

所以在Elux中不再需要任何路由框架(`如react-router、vue-router、taro-router等`)，也没有定死路由规则。路由只存在于 Model 外围，不参与核心逻辑，带来灵活性的同时也降低了心智负担。
