# 分层而治

在曾经的Web1.0时代，浏览器就是一个简单的后台数据渲染器，但发展到今天，它已经能跟各种`胖客户端`一决高下了。

近年来涌现出一些优秀的UI渲染框架，比如React/Vue/Anglar，它们很强大，可以干很多事情，但不要忘了它们始终是一个GUI工具，类似于`Java Swing`和`.Net WPF`，你不能把所有逻辑都写在一个GUI里面，这容易导致你的代码混乱不堪，不知不觉形成一个误区：**GUI就是工程的全部**，只顾解决问题，不思考如何更优雅、更合理的解决问题。

打开你们的Component代码看看，是不是充斥着各种生命周期、各种数据定义、各种渲染逻辑、各种交互逻辑、各种事件逻辑、各种业务处理逻辑、各种数据请求逻辑、各种路由跳转逻辑、各种存储/缓存逻辑等等，轻轻松松几百行代码...

## 状态管理框依然需要

有了Hooks/CompositionAPI就不需要单独的状态管理了？纯技术上来说或许是可以，但有没有想过Hooks/CompositionAPI都是特定UI框架的产物，与UI框架的渲染、生命周期深度耦合。某些简单的数据交流，需要被Props传来传去，即便是我不需要，也要为我的儿孙代传，还要考虑传递和接收是同步还是异步、会不会出现闭包陷阱，会不会导致冗余渲染...好好的一条直路，被UI框架的渲染机制给带偏了。

在JS国度中它们就像各种方言，再加上一些隐晦的心智负担，远没有一个Flux框架条理简单清晰。而且，测试、监控、回滚一个`Action`多容易，你测试、监控、回滚一个`Hooks`试试...

当然并不是说Hooks就不好，不能用了。Hooks属于UI自己的魔术方法，让它处理自己份内事情当然得心应手，而其它非UI职责的事情，虽然它也可以干，但不合适。

::: tip

术有专攻，能说普通话为啥要用方言？

:::

## 将UI框架拉下神坛

UI层不是软件架构的全部，甚至连核心都不是，UI的指责只有2个：**输入与输出**，仅此而已。

它是问题的收集者和结果的反馈者，而不应当成为问题的解决者。

### 应用的核心是业务逻辑

UI的存在只是让用户更友好的使用系统，那么现在问你一个问题：

> 如果你的应用不使用UI，用户可以通过命令来使用吗？

你可能会怼我说，不会有用户通过命令来使用我的应用，这是个没有意义的假设。然而，这种场景或许不是开放给用户使用的，而是给留合作伙伴、留给测试工具、留给日志分析用的呢？

### 不要过度依赖UI层

> - UI说：应用要改版，皮肤、交互、页面组织都要调整，要多久？
> - 产品说：把H5改改，做成小程序、APP吧，要多久？
> - 经理说：React人太难招了，要不我们换成Vue吧，要多久？
> - Leader说：Vue3出来了，我们升级为最新版吧，要多久？

业务逻辑不变，仅调整UI和其运行平台，问你要多久？一个星期？一个月？一年？还是...如果你的回答很勉强，说明你已经过度依赖UI层了...

## 多变的UI界面

UI/UE太感性、太灵活了，带有很强的个人主观色彩，经常会被优化、修改、甚至推翻，不像业务逻辑那么稳定。这也是要将UI逻辑和业务逻辑分开的重要原因，如果你将业务逻辑和UI逻辑写在一起，你本来稳定的代码将受到不稳定代码的严重骚挠。

## 重提软件架构

把UI层变薄，它不过是渲染数据（输出）和收集动作（输入）。\
让Controller、Model层回归，它们才是架构的C位，应用的大脑。\
重提分层而治、重提MVC，让“客观、稳定”的业务逻辑不被“感性、多变”的UI逻辑干挠，保证核心逻辑可以跨越UI框架、跨越运行平台而运行。

## 重振Flux框架

MVC如何落地？大名鼎鼎的Flux架构就是一种 Controller 和 Model 的落地方案。\
`Redux`/`Vuex`/`Pinia`、已及后面要推荐给大家使用的`Elux`，都可以看作它的变种。

### 从State到Model

MVVM应用中充斥着状态，有的用来描述Component的内部状况，它与Component唇齿相依，跟随Component诞生和销毁，这就是我们常说的`ComponentState`。\
还有一些状态，用来描述业务状态，与具体哪个Component没有直接关系，不存在复用与销毁，我们可以称它为`Model`。

- ComponentState 是UI逻辑，应当封装在Component里面，外界也无需知道。
- Model 是业务逻辑，反映整个APP的状况，与Component无关，应当由Flux框架来统一管理。

### 从Event到Action

用户通过UI界面产生的人机交互事件，我们习惯叫"Event事件"，而"Event事件"背后的业务目的我们可以叫"Action动作"，它们一个是因一个是果，一个是表一个本。

- 处理 Event 的 Handler 是UI逻辑，应当写在UI组件中
- 处理 Action 的 Handler 是业务逻辑，应当写在Controller里面

> 举个具体的例子吧："SubmitLoginForm｜提交登录表单"，通常要完成如下逻辑：
>
> 1. 验证输入是否有效
> 2. 验证当前用户是否已经登录
> 3. 请求后端API，并等待返回
> 4. 如果成功，保存用户信息，并跳回原页面
> 5. 如果失败，提示错误，并留在原地

这是一个业务动作，因为它可以不依赖哪个具体UI而运行，用户可能通过“onClick事件”点击登录按钮来触发，也可能通过“onKeyPress”按下回车键来触发，甚至你可以直接让用户通过“Login命令”来触发。

所以“onSubmitLoginForm()”应当写在`Controller`而非UI组件中。\
UI组件中只有"onLoginButtonClick()"或"onEnterKeyPress()"，而它们往往也就一句话，就是Dispatch一个Action来触发`Controller`中的“onSubmitLoginForm()”

将业务逻辑移出UI组件，这样UI层就变薄了，回归到了它的本质：**只负责收集业务动作，不负责处理它**。

## 改良Flux框架

传统的Flux框架也有痛点：

- 全局中心化管理导致逻辑过于集中；
- 单实例、不销毁容易造成信息累积爆炸；
- DispatchAction机制过于简单，不适合处理前因后果的长流程业务。

这里要自荐给大家的Elux框架，正是针对以上痛点进行了改良：

- 虽然坚持全局中心化管理，但Elux提出“微模块”的概念，将应用拆分成独立自治的一个个“微模块”，每个微模块仅处理自己领域内的事情。
- 不再单实例，每次路由变化都会产生一个新的空白Store，然后重新挑选有用的状态挂载，类似一种垃圾回收机制。
- 提出了ActionBus的概念，让Action作为Model中的事件来广播。
- 让Action的处理链条具备“协程”机制，更好的协同各业务动作之间的关联。

## Elux-分层而治

正是因为遵循了`轻UI、重Model`的设计思想，让Elux可以跨框架，可以使用`React/Vue/更多其它UI框架`来开发，可以不用为了React而学习`NextJS`，为了Vue又学习`NuxtJS`，UI框架已经变得没那么重要了。

正式因为分离了`UI逻辑和业务逻辑`，让Elux工程可以跨平台，可以用一种工程模式开发Web(浏览器)、Micro(微前端)、SSR(服务器渲染)、MP(小程序)、APP(手机应用)。

![组件状态与应用状态](/images/three-layers.svg)
